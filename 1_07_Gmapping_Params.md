# Gmapping, параметры, конфиги и map

## Содержание

- [Содержание](#содержание)
- [Подготовимся](#подготовимся)
- [Gmapping](#gmapping)
- [Первые запуски и настройка](#первые-запуски-и-настройка)
- [Параметры в ROS](#параметры-в-ros)
- [Никуда без map фрейма](#никуда-без-map-фрейма)
- [Карта - это матрица](#карта---это-матрица)
- [Цветастая карта](#цветастая-карта)
- [Больше удобства - конфиги](#больше-удобства---конфиги)
- [Чему научились?](#чему-научились)
- [Задание](#задание)

Ух, ну и большая сегодня будет тема! Нам надо разобраться, как запускать кратографирование, настраивать и работать с ним! Поэтому, готовимся узнать много нового!

## Подготовимся

У нас есть launch, который запускает симулятор и дополнительно запускает `robot_state_publisher` для публикации TF и rviz для тображения данных. В этой теме мы будем делать новый launch, который будет не только запускать симулятор, но и включать узел [gmapping](http://wiki.ros.org/gmapping).

Давай задумаемся, как правильно организовать launch для запусков? С одной стороны, мы могли бы скопировать код из `turtlebot3_sim_start.launch` и вставить в новый launch, пусть он будет зваться `turtlebot3_sim_mapping.launch`. Также добавить всё необходимое для картографирования - запуск узла gmapping и новая конфигурация для rviz.

> Так как мы теперь хотим посомтреть, как **строится карта**, а не **посмотреть, как работает робот в симуляторе** - это другая задача, а значит нам нужно создать новую кофнигурацию rviz.

Но получится, что в случае обновления кода запуска симулятора нам тогда надо менять код в двух местах? Это не следует принципу [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself), по которому нужно стараться избегать дублирования, где это можно легко избежать.

Тогда мы можем сделать include launch `turtlebot3_sim_start.launch`, а внутри сделать запуск rviz управляемым (с помощью аргумента и атрибута `if` у `<node>` тэга), а в `turtlebot3_sim_start.launch` сделать запуск rviz со своей конфигурацией! Тогда при запуске `turtlebot3_sim_start.launch` будет запущен один rviz, а при запуске `turtlebot3_sim_mapping.launch` - другой (под другую задачу).

> Если хотите попрактиковаться - сделайте самостоятельно оговоренное, а потом проверьте себя с описанным результатом =)

Значит, в `turtlebot3_sim_start.launch` добавляем следующие конструкцию:

```xml
<launch>
    <arg name="rviz" default="false" />
    ...

    <node if="$(arg rviz)" pkg="rviz" type="rviz" name="rviz" args="-d $(find super_robot_package)/rviz/sim_initial.rviz" />
</launch>
```

Проверь, что запуск `turtlebot3_sim_start.launch` и rviz в нём стал управляемым.

## Gmapping

Отлично, теперь после проведенной подготовки самое время переходить к основному блюду - [gmapping](http://wiki.ros.org/gmapping)!

По сути gmapping - это узел, который занимается построением плоской карты препятствий. Есть и другие реализации данной задачи (hector_mapping, cartographer и др.), но сегодня мы будем пробовать работать именно с этим алгоритмом, так как он представляется проще всего в настройке и запуске.

Давай начнем знакомство сразу с практики! Cоздай launch с названием `turtlebot3_my_gmapping.launch` (название специально отражает, что мы сами разбираемся в нём) и начинкой в виде запуска узла `gmapping`. Должно получиться что-то такое:

```xml
<launch>
  <node pkg="gmapping" type="slam_gmapping" name="gmapping">
  </node>
</launch>
```

> Если тебе непонятно, почему узел запускаем `slam_gmapping`, то ты скорее всего не читал доки по [gmapping](http://wiki.ros.org/gmapping) - посмотри их ещё раз.

И давай сразу для запуска симулятора с новым настраиваемым конфигом rviz сделаем два действия:

1. Скопируем `rviz/sim_initial.rviz` в `rviz/sim_mapping.rviz` - это будет наш конфиг отображения для задачи построения карты
1. Сделаем launch запуска всего этого добра - `turtlebot3_sim_mapping.launch`:

    ```xml
    <launch>
      <arg name="rviz" default="false" />

      <include file="$(find super_robot_package)/launch/turtlebot3_sim_start.launch" />
      <include file="$(find super_robot_package)/launch/turtlebot3_my_gmapping.launch" />

      <node if="$(arg rviz)" pkg="rviz" type="rviz" name="rviz" args="-d $(find super_robot_package)/rviz/sim_mapping.rviz" />    
    </launch>
    ```

Вот так мы сделали launch, который запускает всё это добро с правильной конфгурацией, а также выделили запуск gmapping в отдельный файл, что позволит далее редактировать только его, ведь мы планируем работать только с ним!

Ну что, поехали? Давай запустим нашего робота вместе с картографированием!

## Первые запуски и настройка

Если кто забыл =)

```bash
# Помнишь, что мы rviz по-умолчанию отключаем? Если тебе неудобно - можешь для себя включить запуск rviz по-умолчанию.
# Главное, чтобы тебе было удобно работать со своими инструментами!
roslaunch super_robot_package turtlebot3_sim_mapping.launch rviz:=true
```

Вот мы запустили и видим всё то же, что и видели при обычном запуске симулятора...

<p align="center">
<img src=../assets/01_07_rviz_start.png />
</p>

Естественно, Ватсон! Мы же не настроили Rviz! Главное, что в шапке виднеется `sim_mapping.rviz`, а значит конфиг правильный. Давай добавим информацию из топика `/map` и в качестве Fixed Frame поставим `map`.

<p align="center">
<img src=../assets/01_07_rviz_map.png />
</p>

Другое дело! Вот и наша построенная карт.

Ну что, готово, запустили, всё заработало - на этом закончим?

Не так быстро =) Если посмотришь [раздел параметров](https://wiki.ros.org/gmapping#Parameters), то можно увидеть кучу параметров для настройки у узла. Это одна из важных тем при работе с узлами, так как именно через параметры они настраиваются чаще всего и уметь работать с ними - это неотъемлимый инструмент при работе в ROS.

## Параметры в ROS

Вообще, параметрам посвящен [раздел в ROS официальной документации](http://wiki.ros.org/Parameter%20Server). Мы из него возьмём только часть про узлы и их настройку.

> ! Главное, что надо запомнить касательно параметров - значения параметров хранятся, пока жив мастер. Если мастер перезапускается (`roscore` или первый запущенный launch), то все установленные параметры сбрасываются. Именно поэтому обычно руками параметры задаются только для пробы чего-либо, а в долгосрочной перспективе они должны быть записаны в файлах.

> Мы не будем рассматривать, как задавать параметры через `rosrun`, так как в практике это редко используется, но ты можешь использовать утилиту `rosparam` для установки параметров вручную.

В launch файлах параметры узлам устанавливаются максимально просто!

Внутри тэга `<node>` надо прописать тэг `<param>`, а в нём атрибуты `name` и `value`, которые работают также, как и установка `<arg>` тэга при include другого launch. Вот [доки по тэгу param](http://wiki.ros.org/roslaunch/XML/param).

Так что давай сразу поменяем параметр, который отвечает за то, какой фрейм считать базовым, ведь по-умолчанию у параметра `base_frame` стоит `base_link`, а мы хотим работать с `base_footprint`, чтобы всё было в плоскости Z=0. Так что давай поставим правильное значение этому параметру!

> В документации символ `~` означает, что параметр "приватный", то есть относится именно в узлу. Нас это не будет никак беспокоить, просто есть такой термин.

```xml
  <node pkg="gmapping" type="slam_gmapping" name="gmapping">
      <param name="base_frame" value="base_footprint" />
  </node>
```

Вот так просто! Не забудь сохранить Rviz, перезапусти и убедись, что всё ок!

## Никуда без map фрейма

Если обратить внимание, то только с началом работы с gmapping у на появляется фрейм `map` из стандарта REP-105.

Это так, потому что только система картографирования может предоставлять информацию о перемещении с учетом коррекции по карте. Ведь мы помним, что `odom` хорош, но имеет дрейф, а карта - это источник абсолютных позиций робота, по которым можно этот дрейф корректировать!

Таким образом система картографирования предоставляет наиболее достоверную информацию, поэтому положение робота "на карте" смотрят именно относительно фрейма `map` по стандарту.

> В стандарте может фигурировать ещё один более глобальный уровень `world`, но он чаще используется при использовании GPS и с двумя и более роботами.

Но как же это делает система картографирования? Тут алгоритм внутри сложный, но логика простая: gmapping подписывается на топик `scan` и, используя карту, которую сам же и строит, а также приходящие сканы, производит коррекцию так, чтобы сканы ложились на точки препятствия на карте (чёрные точки).

> :muscle: С помощью параметра `map_frame` поменяй название фрейма, который будет отвечать за карту на `my_map`. Перезапусти и через `rqt_tf_tree` и `rviz` убедись, что изменения применились. Верни после эксперимента обратно на `map`, чтобы соответствовать стандарту =)

## Карта - это матрица

Если попробовать вывести информацию с топика через `rostopic echo /map`, то можно получить кучу нечитаемого вида. Именно поэтому важно уметь представлять информацию различными способами, так как что-то можно посмотреть в числах, а что-то воспринимается визуально (или в другой интерпретации). Мы ведь не смотрим картинки попиксельно?

Так и здесь, карта - это на самом деле прямоугольная матрица из чисел. Если ты знаешь Python, MATLAB или другой язык, касаемо математики (или саму математику), то ты уже знаешь, что матрица - это двумерный массив с некоторым кол-вом строк и столбцом (высота и ширина карты).

Чтобы получить эти значения касательно карты, можно вывести информацию из топика `/map_metadata`:

```md
resolution: 0.05000000074505806
width: 4000
height: 4000
```

Ширина и высота заданы в точках (элементах матрицы), а `resolution` показывает разрешение - сколько метров покрывает каждый элемент матрицы [метров на блок].

Можно считать, что вся карта - это картинка, каждый элемент матрицы - это пиксель, а физический размер пикселя - это разрешение.

Это важно понимать, так как, например, ширину и высоту можно настраивать под свои нужды, чтобы потреблять меньше оперативной памяти, а разрешение часто влияет на скорость обработки и загрузку процессора.

> :muscle: Поменяй параметр `delta` на значения (0.1, 0.01, 0.3, 0.001) и посмотри, как влияет на скорость обработки/детализацию карты.

## Цветастая карта

Отлично, с форматом передачи разобрались, но что значат черные/белые/серые клетки на карте в rviz?

Если посмотреть в [документацию типа топика](http://docs.ros.org/en/api/nav_msgs/html/msg/OccupancyGrid.html) `/map`, то можно увидеть, что в `data` поле хранятся значения "-1" и от 0 до 100. Вот и на карте у нас они отображаются:

<p align="center">
<img src=../assets/01_07_rviz_map_colors.png />
</p>

В отображении карты от gmapping используется три основных цвета:

- черный (значение 100) - точки в матрице, на которых находится препятствие
- белый (значение 0) - точки, где точно нет препятствия
- серый (значений -1) - неизвестно, так как туда не попадал лазер.

Тут можно сразу задать вопрос, а почему между столбами и в некоторых зонах белого появляются серые точки? В первом случае лидар не достаёт до стены на другой стороне карты, поэтому нельзя точно сказать, есть ли там препятствие. Алгоритм gmapping работает по принципу "скан достал до препятствия, значит на пути от робота до этой точки нет препятствий.

> ! Обрати внимание, что в системе карт ROS есть понятие "неизвестная" местность и она отличается от состояния "свободно". Это будет важно понимать при дальнейшей работе.

## Больше удобства - конфиги

В ходе изучения работы gmapping мы пробовали устанавливать разные параметры, но представь, что тебе надо поменять 10, 20 или больше параметров. Это приводит launch к разрастанию (на каждый параметр своя строка).

А что если в launch ещё и не один узел надо так настраивать?

В таком случае было бы удобно вынести конфигурацию параметров в отдельное место. Этим местом будет "конфигурационный файл". А если проще - конфиг.

Можно сделать файл в формате YAML и удобно в нём настраивать под себя узел, а launch будет заниматься своей работой - запускать узлы!

Давай сделаем свой первый конфиг в пакете для узла `gmapping`. Создаём папку `config` внутри пакета. Внутри этой папки создаём файл `gmapping_params.yaml`.

Ну и переносим в него все наши параметры из тэгов `<param>`. Но как перенести, не просто же скопировать строки?

Правильно! YAML работает по принципу "ключ: значение", где ключ - это имя параметра, а значение - это значение =)

Должно получиться что-то наподобие:

```yaml
base_frame: base_footprint
map_frame: map
delta: 0.05
```

Окей, в файл перенесли, но как нам это всё передать в узел? В этом нам поможет тэг [`<rosparam>`](http://wiki.ros.org/roslaunch/XML/rosparam). Мы просто использует атрибуты `command` и `file`. Первый указывает, что надо сделать и из всех представленных в доках нам нужна команда "load". А в `file` как обычно пишем путь до файла конфига (там даже примерчик с `$(file pkg)` есть =)

Получается, запуск узла будет выглядеть так:

```xml
  <node pkg="gmapping" type="slam_gmapping" name="gmapping">
    <rosparam command="load" file="$(find super_robot_package)/config/gmapping_params.yaml" />
  </node>
```

Так мы перенесли конфигурацию узла из launch в отдельнйы конфиг, что разделяет по файлам задачи и делает работу с пакетом удобнее!

## Чему научились?

Вот так незатейливо мы смогли взять узел для картографирования и подключить самостоятельно к нашему роботу. Круто! Молодцы!

Как уже ранее сообщалось, в ROS действительно уже сделано много готового и удобного, поэтому нам не нужно писать самостоятельно софт, но уметь правильно использовать и настраивать - это не менее важный и полезный навык. Главное, это понимать, для чего всё это делается и держать в голове фактор удобства использования!

## Задание

- С помощью `rqt_graph` или утилит `rosnode`, `rostopic` определи, на что подписывается узел `/gmapping`. Проверь, соответсвует ли это документации.
- Определи, на что влияют параметры `linearUpdate` и `angularUpdate`. Настрой их в конфиге под себя и посмотри, как это влияет на коррекцию TF `map`->`odom`.
- Посмотри конфигурацию из пакета `turtlebot3_slam` для gmapping и попробуй взять оттуда разные настройки. Стало ли лучше/быстрее/точнее работать (оценка на глаз)?
- \* Попробуй самостоятельно сделать launch-файлы и запустить hector_slam в качестве картографической системы. Не забудь установить пакеты с помощью `apt`.
