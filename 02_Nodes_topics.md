<!-- omit from toc -->
# Какие-то узлы и топики 

## Содержание

- [Содержание](#содержание)
- [ROS узлы и топики](#ros-узлы-и-топики)
  - [Основные инструменты](#основные-инструменты)
    - [rosnode](#rosnode)
    - [rostopic](#rostopic)
    - [rosmsg](#rosmsg)
  - [Добавим графику](#добавим-графику)
- [Создание ROS Publisher с использованием rospy](#создание-ros-publisher-с-использованием-rospy)
- [Создание ROS Subscriber с использованием rospy](#создание-ros-subscriber-с-использованием-rospy)
- [ROS имена и пространства имен ну и еще мапирование](#ros-имена-и-пространства-имен-ну-и-еще-мапирование)
  - [Node name](#node-name)
  - [Node namespace](#node-namespace)
  - [Node remapping](#node-remapping)
  - [Что нужно сделать](#что-нужно-сделать)
- [Вопросики](#вопросики)
- [С чем познакомились?](#с-чем-познакомились)
- [Полезные ресурсы](#полезные-ресурсы)


## ROS узлы и топики

Вот и подошел черед познакомиться с первыми базовыми вещами ROS - **узлами**. Под узлом подразумевается программа, которая производит некоторые действия. Узлы соединяются **топиками**, через которые передают **сообщения**. Таким образом, приходим к знакомой схемке типа графа.  

Для начала знакомства необходимо запомнить важную вещь! 

> :white_check_mark: В любой экосистеме ROS существует **мастер** (и он единственный), который работает с узлами. Фактически, он полностью организует их. 

<p align="center">
<img src="../assets/lab2/shifu.png" width=300>
</p>

Начнем, чтобы что-то запустить, нужно воспользоваться утилитой запуска узла `rosrun`, которая имеет следующее описание:
`rosrun [pkg_name] [node_name] [additional args]`  
- pkg_name - имя пакета, в котором узел содержится  
- node_name - имя узла в пакете  
- additional args - дополнительные аргументы (рассматривается позже, в нашем случае используется явное задание имени узла в экосистеме ROS (`__name`) )

Let's Go, создаем простейшую систему с топиком и узлами:
- запуск ROS мастера, вся систем зиждется на нем и без него ничего не работает:
```bash
rosсore
```
- узел из пакета `rospy_tutorials` с именем `talker` командой:
```bash
rosrun rospy_tutorials talker
```
- узел из пакета `rospy_tutorials` с именем `listener` командой:
```bash
rosrun rospy_tutorials listener 
```

> :mechanical_arm: Запустите узлы утилиты. Не забывайте про то, что если узел при запуске работает бесконечно, то для запуска другого узла нужен новый терминал.

### Основные инструменты

#### rosnode

Открываем еще один терминал и начинаем анализ системы вместе с испытанием инструментов.

> :brain: Проверьте возможные команды утилиты `rosnode`

Посмотрим список узлов в системе с помощью:

```bash
rosnode list
```

Также можно посмотреть информацию о конкретном узле, например `/talker`:

```bash
rosnode info /talker
```
Команда нам выдаст следующее :point_down:	

```
--------------------------------------------------------------------------------
Node [/talker]
Publications: 
 * /chatter [std_msgs/String]
 * /rosout [rosgraph_msgs/Log]

Subscriptions: None

Services: 
 * /talker/get_loggers
 * /talker/set_logger_level


contacting node http://user-vb:39115/ ...
Pid: 8733
Connections:
 * topic: /chatter
    * to: /listener
    * direction: outbound
    * transport: TCPROS
 * topic: /rosout
    * to: /rosout
    * direction: outbound
    * transport: TCPROS

```

Сделаем небольшой анализ увиденного:
- Узел зовется `/talker`
- Публикует в два топика: `/chatter` и `/rosout`, второй - топик для логирования, в него автоматически публикуют все узлы, более конкретно рассмотрим потом
- Подписок нет
- Имеет два сервиса, которые тоже создаются автоматически у каждого узла, о сервисах потом
- PID (Porcess ID) = 8733 - это идентификатор процесса в системе Linux, нам он не важен
- Имеет соединения, они должны сходиться с названиями подписок и публикаций, таким образом сообщается, что все публикуется и подписывается корректно (соединения между узлами настроены)

> :brain: Попробуйте проанализировать информацию об узле `/listener`

#### rostopic

Теперь взглянем на возможности утилиты для анализа топиков

> :brain: Проверьте возможные команды утилиты `rostopic`

Посмотрим на список топиков в системе
```bash
rostopic list
```

Для вывода в более подробной форме воспользуемся опцией -v

```bash
rostopic list -v
```
```
Published topics:
 * /chatter [std_msgs/String] 1 publisher
 * /rosout [rosgraph_msgs/Log] 2 publishers
 * /rosout_agg [rosgraph_msgs/Log] 1 publisher

Subscribed topics:
 * /chatter [std_msgs/String] 1 subscriber
 * /rosout [rosgraph_msgs/Log] 1 subscriber
 ```

В выводе видна информация о подписках и публикациях топиков.

Взглянем на информацию о конкретном топике

```bash
rostopic info /chatter
```
```
Type: std_msgs/String

Publishers: 
 * /talker (http://user-vb:39115/)

Subscribers: 
 * /listener (http://user-vb:42123/)
```

По выводу можно определить, какие узлы подписаны на топик, а какие публикуют в него сообщения.

Далее можно показать сообщения, которые идут через этот топик. Для завершения нажмите Ctrl+C.

```bash
rostopic echo /chatter
```
```
data: "hello world 1536699023.89"
---
data: "hello world 1536699023.99"
---
...
```

> :brain: Найдите в справке утилиты `rostopic` аргумент измерения частоты публикации и измерьте частоту публикации в топик `/chatter`

#### rosmsg

Также существует утилита `rosmsg`, которая анализирует типы сообщений

> :brain: Проверьте возможные команды утилиты `rosmsg`

В информации о топике мы видели поле типа сообщений, которые идут через этот топик
```
Type: std_msgs/String
```
В типе можно видеть имя пакета типа `std_msgs` и само название `String`. Чтобы просмотреть, что содержит данный тип сообщения, воспользуемся командой

```bash
rosmsg show std_msgs/String
```
Результат:
```
string data
```
Как видно, данный тип сообщения содержит строковое поле `data`. Таким образом утилита анализирует информацию, связанную со строением (прототипом) сообщения, а не c самими данными в них.

А теперь посмотрим, какие есть сообщения в системе ROS 

```bash
rosmsg list
```
Так как их много, вывод не приводится :tired_face:	

Самый основной пакет сообщений - `std_msgs`, его типы можно глянуть командой, которая показывает типы сообщений, определенные в данном пакете

> :brain: Пройдите все представленные шаги, просмотрите типы сообщений `std_msgs/ColorRGBA`, `geometry_msgs/Pose2D`

### Добавим графику

Запустите графическое представление графа экосистемы с помощью утилиты `rqt_graph`. Вы увидите графический интерфейс, на котором отображены узлы и топик в нашей системе. Также можно управлять настройкой группы `Hide`, что позволяет скрывать некоторые элементы в соответствии с настройкой.

> :mechanical_arm:	Включите `rqt_graph` и в группе `Hide` снимите галочку с `Debug`. Убедитесь в том, что представлены все узлы и топики (даже с отладкой) системы, с помощью утилит `rosnode` и `rostopic`. Как видно, узел `/rosout` и топик `/rosout` создаются для отладки и соединяются со всеми узлами через топик `/rosout`.

> :mechanical_arm:	Запустите узел пакета `rospy_tutorials` с именем `listener`, но присвойте имя `__name:=listener2`. Проверьте с помощью `rqt_graph`, что оба `listener` подключилиь на общий топик.

> :mechanical_arm:	Запустите два узла из пакета `rospy_tutorials` с именем `talker` и присвойте им одинаковые имена `__name:=talker`. Убедитесь, что первый `talker` закрылся с сообщением о перехвате (`shutdown request: new node registered with same name`).


## Создание ROS Publisher с использованием rospy

Самое время познакомиться с возможностями написания узлов на языке Python.

Сначала взглянем на код, который будем разбирать:

```python
#!/usr/bin/env python3
import rospy
from std_msgs.msg import String

rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
rate = rospy.Rate(1)

def start_talker():
    msg = String()
    while not rospy.is_shutdown():
        hello_str = "hi =) %s" % rospy.get_time()
        rospy.loginfo(hello_str)

        msg.data = hello_str
        pub.publish(msg)

        rate.sleep()

try:
    start_talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    rospy.logerr('Exception catched')
```

А теперь пошел разбор. Для начала, импортируем основной модуль `rospy` и модуль сообщения типа `std_msgs/String`. 

```python
#!/usr/bin/env python3
import rospy
# Our case:     std_msgs/String     -> from std_msgs.msg import String
# Example:      geometry_msgs/Pose  -> from geometry_msgs.msg import Pose
from std_msgs.msg import String
``` 

После этого необходимо зарегистрировать узел в системе ROS, а также зарегистрировать топик на публикацию с указанием имени, типа сообщения для топика и размера очереди.
Первый аргумент функции `init_node()` задает название, которое будет зарегистрировано в рабочей экосистеме ROS.
Очередь нужна для сохранения сообщений, если узел публикует сообщения часто, при этом низкоуровневая передача сообщений работает медленнее или с задержками. При переполнении очереди отправляются наиболее актуальные данные.
```python
rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
```

При регистрации узла функцией `init_node()` у конструктора есть флаг `anonymous` со значение по-умолчанию `False`. Так при включении этого флага
```python
rospy.init_node('talker', anonymous=True)
```
к указанному имени узла добавляется суффикс (получается, например, `talker_18231_12354`), который делает узел уникальным в системе (свойство **анонимности**).

У функции `rospy.Publisher()` есть флаг `latch` со значение по-умолчанию `False`. Его включение добавляет следующее поведение: при отправке сообщений в топик сохраняется последнее отправленное сообщение и когда кто-нибудь подписался на этот топик - он сразу получает последнее сообщение из этого топика, даже если отправка была раньше, чем узел подписался на топик. Помогает, если в топик один раз опубликовались данные, а другой узел подписался на этот топик намного позже.

После остается только создать объект `Rate`, который используется для выдерживания частоты выполнения кода. В конструктор передается значение частоты в Гц.

```python
rate = rospy.Rate(1) # 1 Hz
```

На этом подготовка и создание необходимых объектов для простейшего узла готовы и пора перейти к основной логике программы.

В API ROS есть функция, которая сообщает о том, что система ROS завершила работу, именно ей и воспользуемся в качестве условия выхода `rospy.is_shutdown()`. Далее определим функцию с основной логикой узла для дальнейшего запуска.

```python
def start_talker():
    # Создаем объект сообщения
    msg = String()
    # Бесконечный цикл, пока ROS система работает
    while not rospy.is_shutdown():
        # Сформируем сообщение, которое включает в себя время
        hello_str = "hi =) %s" % rospy.get_time()
        # Вывод в терминал информации (содержание сообщения)
        rospy.loginfo(hello_str)
        # Заполнение сообщения и публикация сообщения в топик
        msg.data = hello_str
        pub.publish(msg)
        # Сон в соответствии с выдерживаемой частотой
        rate.sleep()
```

После этого можем запустить функцию узла (в ней находится вся логика). При этом заворачиваем в конструкцию `try-catch`, чтобы обработать исключение (нажатием Стоп или Ctrl+C в терминале). 
```python
try:
    start_talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    rospy.logerr('Exception catched')
```

> Задачка по самостоятельной интеграции скрипта в наш пакет:
- :mechanical_arm:	Внутри пакета создать папку `scripts` (Python файлы считаются скриптами), в ней создать файл talker.py и в нем разместить код узла.
- :mechanical_arm:	Далее дать права на выполение с помощью команды `chmod +x talker.py`. Необходимо, чтобы вы находились в одной папке со скриптом.
- :mechanical_arm:	Попробовать запустить в системе ROS созданный узел, для ранее созданного пакета команда будет следующей:  
`rosrun study_pkg talker.py`
- :brain:	Поскольку мы не задавали флаг анонимности в функции `rospy.init_node('talker')` (по-умолчанию там стоит `anonymous=False`), явно присваивать имя узла не требуется, оно будет такое, как было задано в функции `rospy.init_node()`
- :brain:	При возникновении каких-либо ошибок, они будут выведены в терминале 

## Создание ROS Subscriber с использованием rospy

А теперь перейдем к написанию узла подписки. 

Базовый код:
```python
#!/usr/bin/env python3
import rospy
from std_msgs.msg import String

def callback(msg):
    rospy.loginfo("I heard %s", msg.data)

rospy.init_node('listener')
rospy.Subscriber('my_chat_topic', String, callback, queue_size=10)
rospy.spin()
```

Для начала, импортируем основной модуль `rospy` и модуль сообщения типа `std_msgs/String`.
```python
import rospy
from std_msgs.msg import String
```

Далее пишем обработчик приема сообщений из топика, регистрируем узел и подписываемся на топик с указанием обработчика. Обработчик вызывается каждый раз, как узел получает сообщение.
```python
def callback(msg):
    rospy.loginfo("I heard %s", msg.data)

rospy.init_node('listener')
# Не требуется сохранять объект подписки, возврат функции игнорируется
rospy.Subscriber('my_chat_topic', String, callback, queue_size=10)
```

После остается лишь оставить узел работать до завершения системы ROS или прерывания узла (Ctrl+C). В момент регистрации подписки на топик узел уже готов принимать сообщения (прием происходит в отдельном потоке).  
С одной стороны можно использовать `rospy.is_shutdown()`. Такая практика рапространена, если необходимо еще что-то делать в узле помимо приема сообщений.  
Для простого приема сообщений можно вызвать `rospy.spin()`, который будет удерживать программу рабочей до тех пор, пока ROS не завершится или узел не бует прерван. 

```python
# В данном случае достаточно спина, по факту замена `while rospy.is_shutdown()`
rospy.spin()
```

> :mechanical_arm: Создайте также и скрипт `listener.py` в пакете. Запустите оба узла и убедитесь в работоспособности (один отправляет, другой получает сообщения).

## ROS имена и пространства имен ну и еще мапирование

Данная тема определяет важные аспекты, связанные с организацией системы при работе с узлами и топиками. 

### Node name

:white_check_mark: Для начала определим, что **имя узла** - это имя, которое присваивается узлу при его запуске. Для того, чтобы явно указать с каким именем запускать узел, используется аргумент `__name`, например:

```bash
rosrun rospy_tutorials listener __name:=listener
```

> ✅ Знак '`:=`' означает присваивание и будет далее часто использоваться при мапировании, установки значений:baby_chick:.


Установка имени была сделана специально, так как по-умолчанию данный узел создается **анонимным**(это свойство устанавливается в коде узла), что добавляет к его имени `listener` случайный численный суффикс. Именно поэтому мы явно и задали его имя.

> :mechanical_arm: Запустите узел `listener` из пакета `rospy_tutorials` без явного указания имени и посмотрите список активных узлов, обратите внимание на имя узла

> :mechanical_arm: Запустите узел `talker` из пакета `roscpp_tutorials` без явного задания имени и убедитесь в присутствии свойства анонимности. 

> :mechanical_arm: Запустите мастера, один узел `talker` из пакета `rospy_tutorials` с заданием имени и два узла `listener` из пакета `rospy_tutorials` без задания имени. Проверьте `rqt_graph` и убедитесь, что оба `listener` анонимные и подписались на топик `/chatter`

### Node namespace

:white_check_mark: **Пространство имен**- фактически, это префикс имени узла в системе. Концептуально, пространство имен объединяет несколько узлов по определенной задаче, расположению или другому признаку. Задавая пространство `new_ns` узлу `talker`, мы получаем узел в системе `/new_ns/talker` и топик `/new_ns/chatter`.

Задание пространства имен для узла производится аргументом `__ns`. Также можно задать глобальное простанство имен с помощью переменной окружения `ROS_NAMESPACE`. По-умолчанию глобальное пространство имен `/`.

> :mechanical_arm: Запустите узел `talker` с указание аргумента `__ns:=my_ns`. Обратите внимание на имена (префиксы) топиков и узлов.

> :mechanical_arm: (Выполнив предыдущее задание) Запустите узел `listener` без явного задания пространства имен. Убедитесь в том, что `listener` не получает сообщения (нет вывода в терминале). Разберитесь в проблеме, используя `rqt_graph`, `rostopic`, `rosnode`.

Получается, простанство имен может объединять узлы (и, как следствие, их топики).

### Node remapping

:white_check_mark: **Мапирование** - переназначение имени топика. Часто используется для соединения узлов, которые в названии топиков имеют общие имена.

Часто бывает так, что необходимо написать общий узел, в котором задаются имена топиков в общих форматах. Допустим, мы пишем узел-детектор объектов на изображении (RGB -> Found objects), он подписывается на топик `rgb_img`, по которому получает изображение. В топик `objects` он публикует обработанное изображение. Для лучшего представления:

<p align="center">
<img src="../assets/lab2/objects.png" width=300>
</p>

Названия топиков пишутся для наилучшего понимания работы узла и написания документации.

Далее используется драйвер камеры, который публикует в топик `image` изображение с камеры:  

<p align="center">
<img src="../assets/lab2/image.png" width=200>
</p>

А теперь вопрос знатокам, как подключить эти два узла без переписывания кода? Ответ: мапирование топиков - запуск обработчика происходит следующим образом, вот примерчик мапирования топика `image` в `rgb_img`:

```bash
rosrun usb_cam usb_cam_node image:=rgb_img
```

> :mechanical_arm: Запустите узел `talker`, смапировав топик `chatter` в `chat_topic`. Запустите узел `listener`, также смапировав топик `chatter`. Оцените результат утилитой `rqt_graph`.

> :mechanical_arm: Запустите узлы `talker` и `listener`, при этом мапирование произведите только для узла `listener`. Убедитесь, что узлы не соединились через топик (не вывода в `listener`). Разберитесь в проблеме, используя `rqt_graph`, `rostopic`, `rosnode`.

Таким образом, разработчику достаточно назвать имена топиков, с которыми работает узел, в общей манере. Никакого специального названия. Далее при запуске человек может сам переименовать и соединить узлы топиками так, как ему удобно.

### Что нужно сделать

:open_file_folder: Не забудьте добавить ваше детище в репозиторий, который вы создавали на предыдущем занятии. Мы хотим, чтобы вы делали все в одном месте и не размножали ссылки.

> :mechanical_arm: Напишите узел, который публикует в топик четные числа (0, 2, 4, 6 и т.д.) с частотой 10 Гц. Имена скрипта, узла и топика выберите сами. Проверьте корректность частоты публикации.

> :mechanical_arm: На основании предыдщуей задачи дополните программу: при достижении числа 100 отправляйте сообщение в новый топик и сбрасывайте счетчик. Также необходимо создать новый узел с подпиской на этот топик, например overflow_listener.py.

<p align="center">
<img src="../assets/lab2/ex1.png" width=500>
</p>

> :mechanical_arm: На основании предыдущей задачи дополните программу: Создайте два пространства имен для двух контроллеров. Переименуйте узлы и смапируйте топики при запуске. 

<p align="center">
<img src="../assets/lab2/ex2.png" width=600>
</p>

## Вопросики

Над которыми стоит подумать :brain::brain::brain: и записать ответы в отчет

- Какие типы сообщений содержатся в основном пакете - `std_msgs`? Какой командой их можно посмотреть?
- Может ли у одного топика существовать два Publisher? Если да, то как это будет работать? А если нет, то почему? :woozy_face:	
- В чем отличие конструкции `while not rospy.is_shutdown():` и метода `rospy.spin()`?

## С чем познакомились?

- Мы научились таким аспектам организации, как имена узлов, пространства имен и мапирование топиков.
- Все рассмотренные вещи будут активно использоваться для корректной организации экосистемы на машине или в сети.
- Такие приемы позволяют писать узлы в общем виде. Далее один и тот же узел может использоваться для разных задач, при этом как названия самих узлов в системе, так и названия топиков могут быть настроены под конкретную систему.

## Полезные ресурсы

- [Узлы](http://wiki.ros.org/Nodes) и [топики](http://wiki.ros.org/Topics).
- [Написание узлов](http://wiki.ros.org/rospy_tutorials/Tutorials/WritingPublisherSubscriber)
- [Subscribers and Publishers](http://wiki.ros.org/rospy/OverviewPublishers%20and%20Subscribers)
- [Имена](http://wiki.ros.org/Names) и [мапирование](http://wiki.ros.org/Remapping%20Arguments)
