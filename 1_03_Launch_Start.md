# Launch everything!

## Содержание

- [Содержание](#содержание)
- [Привет!](#привет)
- [Подготовка](#подготовка)
- [Мой первый launch](#мой-первый-launch)
- [Залезем чуть глубже](#залезем-чуть-глубже)
- [Аргументы launch](#аргументы-launch)
- [Задание](#задание)
- [Чему научились?](#чему-научились)

## Привет!

Привет! Сегодня мы с тобой узнаем, что такое launch-файлы и утилита `roslaunch`.

Нам довелось пользоваться этой программой, чтобы запускать разные части нашей системы на черепашке. Как мы уже обсуждали ранее, много готового существует в Open Source мире и в ROS пакетах, но что если нам хочется сделать что-то своё? Или как-нибудь организовать то, что уже создано?

Например, нам в моменте запуска системы с черепашкой и управлением надо было запускать три терминала! А с более сложными системами может потребоваться стартовать и под десяток, если посчитать все необходимые части. Давай разберёмся, чем нам поможет `roslaunch`?

## Подготовка

Уже должно быть создано и подключено локальное рабочее пространство, а также создан собственный пакет как репозиторий на GitHub.

## Мой первый launch

Думаю, я порадую вас, если скажу, что вместо запуска двух терминалов (с симулятором и построением карты) можно записать всё в один запуск!

Для начала нам нужно создать папку `launch` и в ней сделать файл `turtlebot3_for_fun.launch` с начинкой:

```xml
<launch>
    <include file="$(find turtlebot3_gazebo)/launch/turtlebot3_world.launch" />
    <include file="$(find turtlebot3_slam)/launch/turtlebot3_slam.launch" />
</launch>
```

Что-то новенькое! Если ты ни разу не встречался с языком разметки XML, то это действительно всё в новинку!

Тут ничего сложного, конструкции в XML построены по принципу открыть-закрыть. В этом тексте `<launch>` - это открывающий тэг, `</launch>` - закрывающий. У тэгов могут быть атрибуты, например `file` у тэга `<include>`. Подробности можно найти в описании [формата launch у roslaunch](http://wiki.ros.org/roslaunch/XML) и конкретно об [`include`](http://wiki.ros.org/roslaunch/XML/include).

Ну, что говорить, сохрани и давай запустим!

```bash
TURTLEBOT3_MODEL=waffle roslaunch super_robot_package turtlebot3_for_fun.launch
```

> Без пересборки ROS сразу видит, что у нас в пакете есть launch файл.

Работает! Появился интерфейс симулятора и Rviz с картой! Убедил? Это работает =)

Итак, теперь подбронее про сам launch формат, он всегда имеет единственный тэг `<launch>`, который обрамляет весь файл!

По сути, launch-файл - это перечисление тех программ, которые надо вместе запустить!

> ! Но очень важно понимать, что в отличии от скриптов, launch не гарантирует последовательный запуск! Это просто список программ и других launch-файлов, которые надо вместе запустить.

Конкретно в нашем файле мы включаем в него (include) два других launch файла, которые запускают симулятор и программы для картографирования по лидару!

Но что это за формат такой? Почему мы как будто пишем путь до файла, а не указываем пакет и т.д.?

Да, у него такой формат, но главное, что нам не надо искать реальный путь до пакета в системе! В этом помагает инструкция `find`, которая, облаченная в `$(...)` позволяет выполнить команду `$(find pkg)` и вместо неё подставится путь до файла в системе. Это ещё и очень переносимый способ, ведь у другого человека расположение пакета `turtlebot3_gazebo` может отличаться!

А дальше мы пишем как и у нас, папка `launch` слэш название файла!

Кстати, список файлов внутри пакета/внутри папки launch можно посмотреть с помощью утилиты `rosls`:

```bash
rosls turtlebot3_gazebo/launch
```

:muscle: Для закрепления попробуй добавить в наш launch ещё один include, который запустит движение по заданию цели и покатайтесь.

> Почему мы не добавляем teleop в launch? Этот узел очень специфичный, он требует работы с фокусом терминала, а у нас от `slam.launch` много сыпется в него, поэтому фокус не получить - надо запускать отдельным терминалом.

## Залезем чуть глубже

Получается, если я могу написать launch-файл, то и другие launch-файлы - это просто текстовые файлы с включениями?

Да! И чтобы посмотреть их начинку воспользуемся утилитой `roscat`! Например, залезем в `turtlebot3_world.launch`:

```bash
roscat turtlebot3_gazebo turtlebot3_world.launch
```

В результате получим:

```xml
<launch>
  <arg name="model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
  <arg name="x_pos" default="-2.0"/>
  <arg name="y_pos" default="-0.5"/>
  <arg name="z_pos" default="0.0"/>

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world"/>
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="true"/>
    <arg name="headless" value="false"/>
    <arg name="debug" value="false"/>
  </include>

  <param name="robot_description" command="$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro" />

  <node pkg="gazebo_ros" type="spawn_model" name="spawn_urdf"  args="-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description" />
</launch>
```

Хмм, а тут немало всего, но новое для нас - это тэги `arg`, `node` и `param`!

А ещё, мы нашли, почему он всё время требует переменную окружения `TURTLEBOT3_MODEL`! Вот и первый момент, который хочется исправить в этих скриптах, чтобы его не задавать!

Так что же это за новые тэги? Разберём кратко:

`arg` - тэг, который позволяет задавать входные аргументы launch-файлу. То есть, можно запустить launch с параметром `x_pos` и это как-то повлияет на запуск. По-умолчанию этот параметр стоит -2.0, поэтому задавать не обязательно. Если не указать `default` атрибут, то надо будет каждый раз при запуске launch указывать!

> Хорошим тоном при написании скрипта является написание атрибута `doc`, который объясняет, что это за параметр. Не переживай, это мы тоже поправим.

`node` - тэг, указывающий запуск программы. Ведь launch - это текстовый файл, который включает инструкции к запуску, а вот **node** (**узел**) в ROS - это сама программа или скрипт, которые содержит исходный код. То есть, сколько не включай один launch в другой, кто-то из них должен стартовать какие-то программы (узлы). Подробнее разберёмся позже!

`param` - подобно переменным окружения в терминале, в ROS есть **параметры**, которые можно задать и тем самым настроить узлы (программы). Это тоже на сладенькое оставим =)

Так, ну теперь мы тут нашли кучу точек для улучшения, значит пора исправлять всё то, что нам не нравится!

> :muscle: Создай свой лаунч `turtlebot3_world.launch` и скопируй туда содерджание исходного launch. И теперь пора вносить исправления!
>
> - Замени обращение `$(env TURTLEBOT3_MODEL)` на свою любимую модельку, чтобы она стартовала по-умолчанию.
> - Напиши `doc` атрибуты параметрам `x_pos`, `y_pos`, `z_pos`. Попробуй представить, что это за аргументы, за что они отвечают. Может и не угадаешь, зато попытаешься, а обновить всегда сможем после проверки позже =)
> 
> После этого проверь, что запуск симулятора из своего пакета работает без задания `TURTLEBOT3_MODEL`.

Отлично, вот так, мы взяли существующий скрипт и улучшили его для себя!

## Аргументы launch

Теперь важно разобраться с аргументами, что это и в чём особенности, потому что таким образом мы можем настраивать запуск без изменения содержимого файла. Это очень удобно!

Во-первых, чтобы проверить, какие аргументы есть в launch-файле, у `roslaunch` есть удобная опция `--ros-args`.

```md
:muscle: Посмотри, как выглядит описание аргументов в новом launch с помощью этой опции.
```

Прекрасно, так можно получить информацию о файле без его открытия. Теперь, как нам задавать их? Ну, тут два пути =)

Первое, мы можем задать значение аргументу при вызове `roslaunch`, делается это так:

> В примере мы используем исходный launch, но не забывай, что у тебя ещё более новый и удобный launch!

```bash
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_gazebo turtlebot3_world.launch z_pos:=4.0
```

Разбираем, запускаем как обычно, но после пишем имя аргумента (name), символ ":=" (привет из паскаля) и значение.

> ! Тут как и в bash пробелы низя (нельзя)

```md
:muscle: Попробуй запустить world launch из своего пакета, задавая `x_pos` и `y_pos`. Ожидаемо ли меняется положение?
А теперь попробуй задать тип модели. А что если задать тип `tobasko`? Что происходит?
```

Такс, ручной метод задания аргументов успешно освоен, но теперь надо научиться заданию аргументов при `include` из другого launch!

Тут тоже несложно! Когда определяем `include` внутри launch просто внутри пишем ещё тэги:

```xml
<include file="$(find turtlebot3_gazebo)/launch/turtlebot3_world.launch" >
    <arg name="z_pos" value="4.0">
</include>
```

Это аналогично команде `TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_gazebo turtlebot3_world.launch z_pos:=4.0`. Удобно, согласись?

Пора применять на практике!

> :muscle: Обнови файл `turtlebot3_for_fun.launch`, чтобы он использовал `turtlebot3_world.launch` из твоего пакета и пропиши новое положение (а может и модель) через аргументы.
> 
> Обязательно проверь, что при запуске всё ок.

Вот подлянка, для `turtlebot3_slam/turtlebot3_slam.launch` и `turtlebot3_navigation/move_base.launch` всё ещё нужен `TURTLEBOT3_MODEL`.

> :muscle: А давай перепишем под себя `turtlebot3_slam/turtlebot3_slam.launch`, `turtlebot3_slam/turtlebot3_gmapping.launch`, `turtlebot3_navigation/move_base.launch`? Тогда launch-файлы из нашего пакета не будут требовать `TURTLEBOT3_MODEL` вообще! 
> 
> Можно и `turtlebot3_teleop/turtlebot3_teleop_key.launch` захватить (переписать для себя), если хочется с клавиатуры управлять и не задавать переменную окружения (тут её вообще можно убрать).

> :muscle: Теперь задание серьёзное, не каждый справляется, но я верю - ты сможешь!
> Разберись в запуске `turtlebot3_world.launch` и найди, где и что управляет запуском GUI Gazebo (интерфейс). Теперь, в launch добавь аргумент, чтобы управлять этим (назови, например, аргумент `gazebo_gui`). По-умолчанию сделай `false`.
> 
> Получилось? А теперь сделай в `turtlebot3_for_fun.launch` тоже аргумент, чтобы можно было управлять этим при запуске `turtlebot3_for_fun.launch`, например: 
> 
> ```bash
> roslaunch super_robot_package turtlebot3_for_fun.launch gazebo_gui:=true
> ```
> 
> Обязательно проверь результат своих трудов!
> (Подсказка) Чтобы подставить значение из одного аргумента в другой надо использовать конструкцию value="$(arg foo)", где foo - это имя аргумента для подстановки.

Воу, если у тебя получилось сделать задание, то ты точно стал гуру аргументов в launch!

Штош, вот мы и познакомились с launch-файлами, что это и как с этим работать. Дальше нас ждёт много интересного, а пока можно наслаждаться тем, что мы уже смогли поправить и сделать удобнее готовые скрипты - это прекрасный результат!

## Задание

Здесь задания пока нет, проверь себя, что в пакете лежат подправленные launch-файлы для turtlebot3, они работают и не требуют `TURTLEBOT3_MODEL`.

Залей обновления в репозиторий, чтобы не потерять!

Если при ходе по топику что-то непонятно - задай вопрос преподавателям!

## Чему научились?

- Файлы launch хранятся в папке launch (спасибо, кэп!)
- Как писать простейшие launch
- Задание аргументов при включении и вручную
