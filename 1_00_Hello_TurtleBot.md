# Hello, TurtleBot!

В этой теме мы улучшим запуск черепашки до трёхмерной модели! Представь себе, робот с кучей крутых датчиков в симуляторе на нашем компьютере! Вау!

## Содержание

- [Содержание](#содержание)
- [Подготовка](#подготовка)
- [Робот, покажись!](#робот-покажись)
- [Пора двигаться!](#пора-двигаться)
- [Научим робота видеть!](#научим-робота-видеть)
- [Робот, который смог (двигаться к цели)!](#робот-который-смог-двигаться-к-цели)
- [Чему научились?](#чему-научились)
- [Задачки](#задачки)
- [Вопросики](#вопросики)

## Подготовка

Так давайте начнём, первым делом установим все необходимые пакеты:

```bash
sudo apt install \
    ros-noetic-gmapping \
    ros-noetic-dwa-local-planner \
    ros-noetic-turtlebot3-gazebo \
    ros-noetic-turtlebot3-teleop \
    ros-noetic-turtlebot3-slam \
    ros-noetic-turtlebot3-navigation
```

## Робот, покажись!

Теперь начнём знакомиться, давайте запустим нашего робота в симуляторе и увидим, что запустилось всё правильно!

```bash
# TURTLEBOT3_MODEL=waffle - означает установку переменной окружения для запуска данной команды (мы указываем желаемую модель)
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_gazebo turtlebot3_world.launch
```

После выполнения команды должен запуститься симулятор **Gazebo**, в котором будет наш робот:

<p align="center">
<img src=../assets/01_waffle_start.png />
</p>

Вон там снизу справа видишь робота? Это наша вафелька! Если быть точнее, то Turtlebot модели Waffle =)

Попробуй приблизиться с помощью левой, правой клавиш мыши и колёсика (на колёсико ещё можно нажимать) и разглядень поближе:

<p align="center">
<img src=../assets/01_waffle_close_view.png />
</p>

Какая хорошая детализация, не так ли? Красивый робот =)

Полюбуйся ещё минутку на робота, осмотри карту и двигаем дальше!

## Пора двигаться!

Робот в симуляторе - это безопасная зверюшка, с которой можно делать что угодно, даже если и сломается, то перезапуск всё починет!

Чтобы заставить робота двигаться, надо передать роботу команды управления. Сейчас мы его просто запустили, даже немного осмотрели, но ничего не передаём.

Давай запустим команду, которая включит возможность управления роботом с клавиатуры, как мы делали с 2D черепашкой:

> **Симулятор не выключайте!** Делаем это в отдельном окне!

```bash
# Обратите внимание, тут тоже просят модельку задать
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
```

:muscle: Таакс, настроили окна, положили пальцы на WASD (ещё X для хода назад) и погнали!

<p align="center">
<img src=../assets/01_waffle_keyboard_control.png />
</p>

Отлично! Но подумай, чтобы управлять роботом, нам нужно смотреть сверху, где он находится. Ты в симуляторе смотришь с птичьего вида, а что если нам нужно работать с роботом, которому надо залазить в очень тесные и непролазные места? Нужно научить робота видеть самого!

## Научим робота видеть!

Чтобы дать роботу глаза потребуется две составляющие:

- Датчик, который передаёт информацию об окружающем мире;
- Программа, которая обрабатывает данные с датчика и позволяет воспринимать информацию о дистанции до объектов.

В качестве датчика у нас будет выступать **лидар**! Смотри, где он установлен:

<p align="center">
<img src=../assets/01_waffle_lidar.png />
</p>

Подробности о лидаре узнаешь на лекциях, а пока считаем, что это датчик, который сканирует плоскость и получает информацию о расстояниях до препятствий вокруг (360 градусов).

Отлично! Датчик у нас есть, а теперь давай в третьем терминале запустим программу, которая позволит роботу получать информацию с датчиков и обрабатывать её:

```bash
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_slam turtlebot3_slam.launch
```

<p align="center">
<img src=../assets/01_waffle_mapping.png />
</p>

Если всё запустилось правильно, то запустились программы для получения и обработки данных с лидара. Ты можешь их видеть в интерфейсе программы **rviz**. Rviz - это интерфейс отображения информации в системе робота.

Тут немного разберёмся, в Gazebo виден виртуальный мир симулятора, будто ты смотришь своими глазами, а Rviz - это интерфейс для отображения разной информации, которая есть в роботе! По сути, это взгляд глазами робота. Подумай, своими глазами сверху видишь всю карту, а робот видит только часть, пока никуда не двигался.

Давай посмотрим на информацию пока только с лидара? Отключаем отображение карты, чтобы были видны только робот и данные с лидара:

<p align="center">
<img src=../assets/01_waffle_map_disabled.png />
</p>

Отлично, теперь видно только то, что приходит с лидара без обработки!

Давай попробуем немного поменять наш виртуальный мир и убедиться, что информация с лидара меняется! 

Поставь цилиндр на свою карту с помощью кнопки цилиндра и проверь, как поменялись ваши данные с лидара:

<p align="center">
<img src=../assets/01_waffle_new_object.png />
</p>

Поменялись? Понимаешь, как они меняются, если ставите цилиндр в разных местах?

Попробуй попередвигать/поразворачивать/изменять размер цилиндра с помощью этого меню:

<p align="center">
<img src=../assets/01_gazebo_object_control.png />
</p>

Убедись, что вы понимаете, как меняются данные с лидара. Если нет - двигай ещё =)

:muscle: Небольшое задание, попробуй поменять размер (диаметр) цилиндра так, чтобы он пропал с лидара. Зависит ли диаметр пропадания от расстояния?

Отлично, после небольшого исследования возвращаем карту на место (включаем в rviz). Если мы активно двигали цилиндр, то на карте можно увидеть такие участки:

<p align="center">
<img src=../assets/01_rviz_map_dirty.png />
</p>

Это остатки рабочей системы построения карты в нашей среде. Ведь в Rviz мы только отключили отображение карты, но построение карты работало в фоне всё это время! 

Но не беда, сейчас мы будем катать по карте и в ходе покатушек карта обновится и ложные препятствия пропадут.

:muscle: Упс, я уже немного раскрыл следующее задание.. Ну ничего, поехали, переключаем фокус на терминал с управлением с клавиатуры (если закрыли, не беда, просто включите управление teleop) и твоя задача - построить карту нашей небольшой местности. А если чувствуешь в себе дух гонщика, то попробуй сделать это на скорость!

Представляешь, ты всего лишь с помощью пары команд смог запустить робота в симуляторе и уже катаешь его с помощью своей собственной клавиатуры и строишь карту! Круто, правда?

Но согласись, сегодня дистанционным управлением по кнопкам никого не удивить, давай заставим робота двигаться к цели, учитывая информацию с карты?

## Робот, который смог (двигаться к цели)!

Давай выключим управление teleop и запустим программу, которая будет учитывать карту с данными с лидара и строить 

```bash
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_navigation move_base.launch
```

Вроде запустили move_base вместо teleop, но ничего не поменялось. Правильно, ведь при управлении с клавиатуры тоже ничего не было видно - робот просто стоял и ждал команды, как ему двигаться.

Теперь, робот не ждёт команды с клавиатуры, а ждёт задания цели, куда ему двигаться. Давайте ему зададим эту цель с помощью кнопки `2D Nav Goal`:

<p align="center">
<img src=../assets/01_rviz_nav_goal.png />
</p>

> Для задания включаете кнопку, левой кнопкой зажимаете в том месте, где хочется остановиться, а затем с зажатой кнопкой управляете направлением постановки.

:muscle: Покатайтесь, посмотрите вид окна gazebo и rviz. Постарайтесь построить полную карту.

Но есть очень важное неудобство, мы не видим маршрута, по которому поедет робот, и цели, куда ему надо ехать. Давайте отобразим эту информацию в rviz!

> Почему именно в rviz? Gazebo - это наш вид из глаз, поэтому мы на нём отобразить информацию не можем. А вот Rviz может отображать информацию, о которой знает робот, поэтому, это самое подходящее место для визуализации!

> Здесь будет без картинки - начинаем привыкать искать подходящие кнопки

В меню Displays (слева в окне) нажимаем `Add`, затем выбираем вкладку `By topic` и ищем путь `/move_base/current_goal`. Выбираем под этим путём строку Pose (с красной стрелкой) и дважды кликаем по ней или снизу нажимаем `OK`.

Отлично, если сейчас задать цель движения, то будет видно, куда он должен двигаться! Круто и очень удобно.

Но ещё, чтобы понимать, как робот поедет, давай отобразим путь робота!

Аналогично переходим в меню выбора отображения (`Add`->`By topic`), выбираем путь `move_base/NavfnROS/plan` и там выбираем Path (зеленая линия). Перед тем, как окончательно выбрать, внизу в Display Name наберите "Global Path".

Отлично, теперь мы видим путь до места, как "планирует" двигаться робот, но зеленый цвет - это очень ярко, поэтому давайте настроим отображение!

В меню Displays найдите Global Path (с зеленой линией), раскройте его, и давайте настраивать:

- Line Style ставим Billboards
- В меню Color выбираем любимый цвет
- В Line Width ставим желаемую толщину линии

Иии, вот так нехитро мы настроили то, как мы хотим видеть информацию внутри робота. Отлично!

Вот так мы научились запускать весь необходимый стек для управления роботом по заданию цели! Поздравляю!

Осталось дело за малым, в следующих темах подробно разобрать, что под этим лежит, чтобы в будущем ты смог сделать своего робота и запустить все необходимое!

## Чему научились?

- Запускать симулятор с роботом из готовых launch-файлов
- Чуток научились работать с Gazebo
- Запускать и управлять (задавать роботу команды) с клавиатуры
- Запускать построение карты по лидару
- Запускать управление через задание цели на карте робота (которую построил робот)
- Работать с интерфейсом отображения информации Rviz

Молодец!

## Задачки

Настала время первых эксперименов! Они очень полезны, так как пытаясь поменять что-то в системе и понять, почему так происходит, Вы приобретаете кучу опыта!

- Давайте кататься на карте `turtlebot3_house.launch` и `turtlebot3_autorace.launch`.
- В данных Image поменяйте ImageTopic на `/camera/rgb/image_raw` и покатайтесь. Как думаете, что это за информация?
- Попробуйте отключить RobotModel, включить TF и покататься по карте. Подсказка, TF - это разные системы координат. Как Вы думаете, почему часть TF стоит на месте, а часть двигается? Какие TF стоят на месте? Отключить часть TF можно в меню TF->Frames.
- Попробуйте поменять модель робота на другую: `waffle_pi`, `burger`.

## Вопросики

- Из каких частей состоит управление роботом по заданию цели? Что нужно роботу, чтобы реализовать такое?
- В чем отличие управление по заданию цели и управление с клавиатуры?
- Что нужно, чтобы обеспечить роботу возможность видеть? А если слышать или чувствовать запахи?
- Какие проблемы имеет лидар?
- Какая программа позволяет отобразить данные, которые есть внутри робота?
- Какая программа позволяет смотреть на симулятор глазами внешнего наблюдателя? 
