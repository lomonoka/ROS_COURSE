# Узлы и топики

## Содержание

- [Содержание](#содержание)
- [Привет](#привет)
- [Запустим всё для управления](#запустим-всё-для-управления)
- [Программы - узлы](#программы---узлы)
- [Каналы передачи данных - топики](#каналы-передачи-данных---топики)
- [RQT Graph](#rqt-graph)
- [Запуск](#запуск)
- [Master](#master)
- [Чему научились?](#чему-научились)
- [Вопросики](#вопросики)

## Привет 

Итак, мы уже касались вопроса программ в ROS. Не раз запускали Gazebo и Rviz, но теперь пара раз и навсегда определиться с понятиями **узел** и **топик**.

А делать мы это будем путём выяснения, как работает teleop управление и как задаются команды управления!

## Запустим всё для управления

Давай запустим симулятор и включим телеуправление с клавиатуры. Конечно, когда запустили, надо немного покататься! Естественно, чтобы убедиться в работоспособности, а не только, чтобы развлечься =)

```bash
roslaunch super_robot_package turtlebot3_world.launch
# Следующая команда в отдельном терминале
roslaunch super_robot_package turtlebot3_teleop_key.launch
```

Итого, мы имеем симулятор (Gazebo) и управление с клавиатуры:

<p align="center">
<img src=../assets/01_05_gazebo_teleop_key.png />
</p>

Шикарно, начнём!

## Программы - узлы

Уже говорили, что программы и скрипты в ROS называются узлами (nodes). Это всё, что надо знать про определение =)

Что интереснее, как с ними взаимодействовать?

Для начала, надо понять, что при запуске робота запускается сразу несколько узлов, а значит нам нужен способ посмотреть весь список запущенных узлов.

В любой работе относительно узлов нам поможет утилита `rosnode`:

```bash
rosnode list
```

В выводе видим:

```md
/gazebo
/gazebo_gui
/rosout
/turtlebot3_teleop_keyboard
```

Прямо сейчас запущено всего 4 узла, пройдёмся, что это за узлы:

- `gazebo` - сервер симуляции, по сути, делает все вычисления физики симулятора;
- `gazebo_gui` - графический интерфейс (GUI) для симулятора, если помнишь, его можно отключить;
- `rosout` - это узел, который стартует всегда в системе ROS, он обрабатывает вывод из других узлов (консольный вывод);
- `turtlebot3_teleop_keyboard` - наш узел управления с клавиатуры.

Вроде несложно, так? 

Тогда, чтобы разобраться с тем, как работает управление с клавиатуры, нам надо глубже копнуть в информацию об узле управления, для этого есть команда `info`:

```bash
rosnode info /turtlebot3_teleop_keyboard
```

Вывод

```md
--------------------------------------------------------------------------------
Node [/turtlebot3_teleop_keyboard]
Publications: 
 * /cmd_vel [geometry_msgs/Twist]
 * /rosout [rosgraph_msgs/Log]

Subscriptions: 
 * /clock [rosgraph_msgs/Clock]
```

Разберём-с, узел управления с клавиатуры имеет "Publications" и "Subscriptions". Что-то публикуется и на что-то он подписывается. Вот тут мы начинаем пересекаться с понятием **топика**. Пойдёём разберёмся с ними!

## Каналы передачи данных - топики

Давай взглянем на то, как организовано общение между узлами в ROS:

<p align="center">
<img src=../assets/01_05_nodes_topics_intro.png />
</p>

Есть ещё такая gif-ка:

<p align="center">
<img src=../assets/01_05_nodes_topics_intro.gif />
</p>

В ROS каждый узел выполняет свою задачу, но они не могут работать без коммуникации между собой. Так вот топики - это один из способов общения между узлами. Как видно на картинке, узлы могут *публиковать в топики* (Publication - отправлять через него данные) и *подписываться на топики* (Subscription - получать через него данные).

Ну, а в нашем примере, `teleop` подписывается на `/clock`, а публикует в `/cmd_vel` и `/rosout`.

Если `/clock` и `/rosout` - это сервисные топики, то `/cmd_vel`, полагаем, отправляет интересную информацию!

Давай проанализируем топики в системе с помощью утилиты `rostopic` и команды `list`:

```bash
rostopic list
```

Вот видим в выводе много разных топиков и в частности:

```md
...
/clock
/cmd_vel
...
```

Ну, просто получить список полезно, но мы также можем и получить информацию о конкретном топике командой `info`:

```bash
rostopic info /cmd_vel
```

Вывод:

```md
Type: geometry_msgs/Twist

Publishers: 
 * /turtlebot3_teleop_keyboard (http://alexey-home-pc:34797/)

Subscribers: 
 * /gazebo (http://alexey-home-pc:34455/)
```

Вот так мы можем видеть, что узел публикации подтвердился, `/turtlebot3_teleop_keyboard`, а ещё мы увидели, кто подписался на топик, `/gazebo` - симулятор!

Давай теперь сами подпишемся на топик и посмотрим, какая информация ходит через него?

```bash
rostopic echo /cmd_vel
```

И у нас непрерывно покатился вывод:

```md
...
linear: 
  x: 0.0
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0
...
```

А вот это уже интересно, давай попробуем поуправлять в терминале телеуправления и параллельно смотреть на вывод из подписки /cmd_vel:

<p align="center">
<img src=../assets/01_05_topic_cmd_vel_values.gif />
</p>

Смотри, значения меняются! Значит, через этот топик передаётся информация о команде на движение. Если более конкретно, то через `linear/x` поле передаётся желаемая линейная скорость, а через `angular/z` - команда на скорость поворота.

> ! Таким образом, топик - это канал передачи потоковой информации (так как передаем непрерывно). Данные внутри передаются с определённой структурой, которая регламентирована **типом сообщения у топика**. Это видно и на картинке, а в нашем случае `/cmd_vel` имеет тип "geometry_msgs/Twist". О каждом типе можно почитать в [справке](http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html) или через команду `rosmsg show geometry_msgs/Twist`.

Для аналогии можно привести конвеерную ленту, через которые передаются коробки конкретной формы и размера. информацию о коробке позволяет получить утилита `rosmsg`.

> :muscle: Посмотри, из каких подтипов состоит сообщение `geometry_msgs/Twist` (`geometry_msgs/Vector3`). Найди информацию об этом типе в справке и в `rosmsg`.

А каким образом определить частоту передачи этого потока? Ведь в поток публикуется с каким-то периодом, мы же все знаем про дискретные системы. Попробуй разобраться самостоятельно:

> :muscle: Определи команду у `rostopic`, которая позволяет вывести частоту публикации в топик.

Вот так мы в общих чертах познакомились с узлами и топиками, но это были цветочки, а теперь будут ягодки!

## RQT Graph

Это всё хорошо, но погодите, нам каждый раз, когда хотим посмотреть как и куда направляется информация, надо по каждому топику и узлу выводить информацию?

Отличный вопрос, конечно же нет! Для этого сделана удобная утилита `rqt_graph`, которая показывает, как и через что связаны узлы, проверим:

```bash
rqt_graph
```

И видим:

<p align="center">
<img src=../assets/01_05_rqt_graph.png />
</p>

> Убедись,что настроено меню сверху вот так, иначе много лишних топиков показывается:

<p align="center">
<img src=../assets/01_05_rqt_graph_setup.png />
</p>

Сейчас у нас немного информации между узлами передается, но в сложных системах такие диаграммы позволяют найти ситуации очепяток и других проблем, которые не дают системе нормально работать.

Вот такой простой и удобный инструмент!

## Запуск

Мы уже увидели, что узел teleop передает информацию через топик `/cmd_vel`, даже посмотрели эти сообщения, определили тип, описание.

Да мы даже запускали уже сколько узлов, но пора разобраться раз и навсегда, как делается запуск узлов!

Итак, запуск в консоли делается командой `rosrun` с аргументами `имя пакета` и `имя узла`. Например, для запуска `turtlebot3_teleop_key` из пакета `turtlebot3_teleop` делается командой:

```bash
rosrun turtlebot3_teleop turtlebot3_teleop_key
```

Аналогично, запуск из launch той же команды делается определением:

```xml
  <node pkg="turtlebot3_teleop" type="turtlebot3_teleop_key" name="turtlebot3_teleop_keyboard">
  </node>
```

Ещё раз разберём семантику атрибутов тэга `<node>`:

- `pkg` - название пакета, из которого запускаем,
- `type` - название узла, который в пакете надо запустить,
- `name` - как узел будет называться в системе,
- `args` - аргументы узла (здесь не представлены).

Отлично, как запускать какие-то узлы мы узнали, но давай подумаем с практической точки зрения. Если у сообщений через топики есть конкретный тип, а значит и формат, то мы можем использовать любой узел, который сможет публиковать сообщения с тем же типом в топик.

В таком случае мы можем заменить узел управления на другой, более удобный.

Посмотрим на этот [узел телеуправления](https://github.com/ros-teleop/teleop_twist_keyboard).

Попробуем установить его через apt:

```bash
sudo apt install ros-noetic-teleop-twist-keyboard
```

А теперь отключим наш исходный узел телеуправления и запустим новый!

```bash
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
```

И, поехали! Обрати внимание, кнопки для управления другие.

Отлично, мы опробовали запуск через `rosrun`, а теперь попробуем сделать запуск с указанием предельных значений через launch. Создадим файл `turtlebot3_teleop_new.launch` и в нём пропишем запуск нового узла с параметризацией, как задано на странице GitHub:

```xml
<launch>
  <node pkg="teleop_twist_keyboard" type="teleop_twist_keyboard.py" name="turtlebot3_teleop_keyboard"  output="screen">
    <param name="speed" value="0.4" />
    <param name="turn" value="0.7" />
  </node>
</launch>
```

Про **параметры** узла мы ещё не говорили, но уже сейчас хочется настроить управление для более удобного контроля робота. Поэтому, настраивай конфигурацию под себя и поехали дальше!

## Master

Последнее, что нам нужно узнать сегодня про узлы - это из маааленькая специфика работы. Зовётся эта маленькая, но очень важная специфика - **мастер**.

Закрой все узлы и попробуй запустить новый узел управления:

```bash
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
```

Или `rviz`, или `rosnode list`.

Все они говорят о следующих ошибках:
- `Unable to register with master node [http://localhost:11311]: master may not be running yet.`
- `ERROR: Unable to communicate with master!`
- `Could not contact ROS master at [http://localhost:11311], retrying...`

Все сообщают о том, что мастер не запущен! Да кто же этот ваш *мастер*?

Всё просто, посмотри на эту схему:

<p align="center">
<img src=../assets/01_05_master.png />
</p>

В части топиков и узлов, мастер выступает как хранитель информации. Когда узел публикует информацию, он сообщает, какой тип сообщений топика и как зовется топик для публикации мастеру. Аналогично при подписке узел запрашивает у мастера информацию по топику, есть ли топик с таким именем, какой у него тип (проверяет соответсвие) и т.д.

Вот так мастер стоит между подпиской и публикацией, чтобы организовать правильно все каналы связи!

Почему тогда всё работает, если сначала запустить launch через `roslaunch`? Roslaunch - это хитрая утилита, которая запускает мастера, если он ещё не запущен. Вот так, без каких-либо вопрсов =)

> Можно ещё в логе старта увидеть строку "auto-starting new master"

А что же делать, если надо запустить один только узел без `roslaunch`? Тут тоже всё просто, надо сначала запустить `roscore`! Попробуй сначала стартануть `roscore`, а потом запускать узлы, что запускали ранее! Видишь, всё работает!

> ! Итого, мастер существует, пока запущен `roscore` или пока работает первый `roslaunch`, который его запускает.

## Чему научились?

- Получилось запустить новый узел телеуправления
- Освоен новый инструмент визуализации `rqt_graph`

## Вопросики

- Что такое rosmaster? Зачем он нужен? Почему без него не стартуют узлы?
- Почему при запуске launch не нужно стартовать roscore?
- Какая команда `rostopic` отвечает за определение частоты публикации в топик?
